private int[] findVerticalSeam(boolean transposeOn) {
    int seam_len;
    int[] vert_seam;
    double[][] distTo;
    DirectedEdge2D[][] edgeTo;
    if (transposeOn) {
        seam_len = pic_j;
        vert_seam = new int[seam_len];
        distTo = new double[pic_i][pic_j];
        edgeTo = new DirectedEdge2D[pic_i][pic_j];
        // Initialize distTo and edgeTo
        for (int i = 0; i < pic_j; i++) {
            for (int j = 0; j < pic_i; j++) {
                edgeTo[j][i] = new DirectedEdge2D();
                if (i == 0) {
                    distTo[j][i] = 0.0;
                    edgeTo[j][i].setEdge(i, j, i, j, 0.0);
                }
                else {
                    distTo[j][i] = Double.POSITIVE_INFINITY;
                }
            }
        }
        // Find paths
        for (int i = 1; i < pic_j; i++) {
            for (int j = 0; j < pic_i; j++) {
                double val = distTo[j][i - 1] + energy_pix_tr[j][i];
                if (distTo[j][i] > val) {
                    distTo[j][i] = val;
                    edgeTo[j][i].setEdge(i - 1, j, i, j, val);
                }
                if (j - 1 >= 0) {
                    val = distTo[j - 1][i - 1] + energy_pix_tr[j][i];
                    if (distTo[j][i] > val) {
                        distTo[j][i] = val;
                        edgeTo[j][i].setEdge(i - 1, j - 1, i, j, val);
                    }
                }
                if (j + 1 < pic_i) {
                    val = distTo[j + 1][i - 1] + energy_pix_tr[j][i];
                    if (distTo[j][i] > val) {
                        distTo[j][i] = val;
                        edgeTo[j][i].setEdge(i - 1, j + 1, i, j, val);
                    }
                }
            }
        }
        // Find min cost at last row
        double min_val = Double.POSITIVE_INFINITY;
        int j_ind = 0;
        for (int j = 0; j < pic_i; j++) {
            if (min_val > distTo[j][pic_j - 1]) {
                min_val = distTo[j][pic_j - 1];
                j_ind = j;
            }
        }
        int i_ind = pic_j - 1;
//            edu.princeton.cs.algs4.StdOut.println(i_ind + " " + j_ind);
        while (i_ind >= 0) {
            vert_seam[i_ind] = j_ind;
            j_ind = edgeTo[j_ind][i_ind].w1;
            i_ind--;
        }
    }
    else {
        seam_len = pic_i;
        vert_seam = new int[seam_len];
        distTo = new double[pic_j][pic_i];
        edgeTo = new DirectedEdge2D[pic_j][pic_i];
        // Initialize distTo and edgeTo
        for (int j = 0; j < pic_j; j++) {
            for (int i = 0; i < pic_i; i++) {
                edgeTo[j][i] = new DirectedEdge2D();
                if (i == 0) {
                    distTo[j][i] = 0.0;
                    edgeTo[j][i].setEdge(j, i, j, i, 0.0);
                }
                else {
                    distTo[j][i] = Double.POSITIVE_INFINITY;
                }
            }
        }
        // Find paths
        for (int i = 1; i < pic_i; i++) {
            for (int j = 0; j < pic_j; j++) {
                double val = distTo[j][i - 1] + energy_pix[j][i];
                if (distTo[j][i] > val) {
                    distTo[j][i] = val;
                    edgeTo[j][i].setEdge(j, i - 1, j, i, val);
                }
                if (j - 1 >= 0) {
                    val = distTo[j - 1][i - 1] + energy_pix[j][i];
                    if (distTo[j][i] > val) {
                        distTo[j][i] = val;
                        edgeTo[j][i].setEdge(j - 1, i - 1, j, i, val);
                    }
                }
                if (j + 1 < pic_j) {
                    val = distTo[j + 1][i - 1] + energy_pix[j][i];
                    if (distTo[j][i] > val) {
                        distTo[j][i] = val;
                        edgeTo[j][i].setEdge(j + 1, i - 1, j, i, val);
                    }
                }
            }
        }
        // Find min cost at the last row
        double min_val = Double.POSITIVE_INFINITY;
        int j_ind = 0;
        for (int j = 0; j < pic_j; j++) {
            if (min_val > distTo[j][pic_i - 1]) {
                min_val = distTo[j][pic_i - 1];
                j_ind = j;
            }
        }
        int i_ind = pic_i - 1;
        while (i_ind >= 0) {
//                edu.princeton.cs.algs4.StdOut.println(j_ind);
            vert_seam[i_ind] = j_ind;
            j_ind = edgeTo[j_ind][i_ind].v1;
            i_ind--;
        }
    }

    return vert_seam;
}
private int[] findVerticalSeamV2(boolean transposeOn) {
    int seam_len;
    int[] vert_seam;
    double[][] distTo;
    DirectedEdge2D[][] edgeTo;
    if (transposeOn) {
        seam_len = pic_j;
        vert_seam = new int[seam_len];
        distTo = new double[pic_i][pic_j];
        edgeTo = new DirectedEdge2D[pic_i][pic_j];

        for (int i = 0; i < pic_i; i++) {
            for (int j = 0; j < pic_j; j++) {
                edgeTo[i][j] = new DirectedEdge2D();
                if (j == 0) {
                    distTo[i][j] = 0.0;
                    edgeTo[i][j].setEdge(i, j, i, j, 0.0);
                }
                else distTo[i][j] = Double.POSITIVE_INFINITY;
            }
        }
        for (int i = 0; i < pic_i - 1; i++) {
            for (int j = 0; j < pic_j; j++) {
                double val = distTo[i][j] + energy_pix_tr[i + 1][j];
                if (distTo[i + 1][j] > val) {
                    distTo[i + 1][j] = val;
                    edgeTo[i + 1][j].setEdge(i, j, i + 1, j, val);
                }
                if (j - 1 >= 0) {
                    val = distTo[i][j] + energy_pix_tr[i + 1][j - 1];
                    if (distTo[i + 1][j - 1] > val) {
                        distTo[i + 1][j - 1] = val;
                        edgeTo[i + 1][j - 1].setEdge(i, j, i + 1, j - 1, val);
                    }
                }
                if (j + 1 < pic_j) {
                    val = distTo[i][j] + energy_pix_tr[i + 1][j + 1];
                    if (distTo[i + 1][j + 1] > val) {
                        distTo[i + 1][j + 1] = val;
                        edgeTo[i + 1][j + 1].setEdge(i, j, i + 1, j + 1, val);
                    }
                }
            }
        }
        double min_val = Double.POSITIVE_INFINITY;
        int i_ind = 0;
        for (int j = 0; j < pic_i; j++) {
//                StdOut.println(distTo[j][pic_j - 1] + " " + j + " " + (pic_j - 1));
            if (min_val > distTo[j][pic_j - 1]) {
                min_val = distTo[j][pic_j - 1];
                i_ind = j;
            }
        }
        int j_ind = pic_j - 1;
//            edu.princeton.cs.algs4.StdOut.println(i_ind + " " + j_ind);
        while (j_ind >= 0) {
            vert_seam[j_ind] = i_ind;
//                StdOut.println(i_ind + " " + j_ind);
            i_ind = edgeTo[i_ind][j_ind].v1;
            j_ind--;
        }
    }
    else {
        seam_len = pic_i;
        vert_seam = new int[seam_len];
        distTo = new double[pic_j][pic_i];
        edgeTo = new DirectedEdge2D[pic_j][pic_i];

        for (int i = 0; i < pic_i; i++) {
            for (int j = 0; j < pic_j; j++) {
                edgeTo[j][i] = new DirectedEdge2D();
                if (i == 0) {
                    distTo[j][i] = 0.0;
                    edgeTo[j][i].setEdge(j, i, j, i, 0.0);
//                        StdOut.println("0 set for " + j + " " + i);
                }
                else distTo[j][i] = Double.POSITIVE_INFINITY;
            }
        }
        for (int i = 0; i < pic_i - 1; i++) {
            for (int j = 0; j < pic_j; j++) {
//                    StdOut.println("running for " + j + " " + i);
                double val = distTo[j][i] + energy_pix[j][i + 1];
                if (distTo[j][i + 1] > val) {
                    distTo[j][i + 1] = val;
                    edgeTo[j][i + 1].setEdge(j, i, j, i + 1, val);
                }
                if (j - 1 >= 0) {
                    val = distTo[j][i] + energy_pix[j - 1][i + 1];
                    if (distTo[j - 1][i + 1] > val) {
                        distTo[j - 1][i + 1] = val;
                        edgeTo[j - 1][i + 1].setEdge(j, i, j - 1, i + 1, val);
                    }
                }
                if (j + 1 < pic_j) {
                    val = distTo[j][i] + energy_pix[j + 1][i + 1];
                    if (distTo[j + 1][i + 1] > val) {
                        distTo[j + 1][i + 1] = val;
                        edgeTo[j + 1][i + 1].setEdge(j, i, j + 1, i + 1, val);
                    }
                }
            }
        }
        double min_val = Double.POSITIVE_INFINITY;
        int j_ind = 0;
        for (int i = 0; i < pic_j; i++) {
//                StdOut.println(distTo[i][pic_i - 1] + " " + i + " " + (pic_i - 1));
            if (min_val > distTo[i][pic_i - 1]) {
                min_val = distTo[i][pic_i - 1];
                j_ind = i;
            }
        }
        int i_ind = pic_i - 1;
        while (i_ind >= 0) {
            vert_seam[i_ind] = j_ind;
//                StdOut.println(i_ind + " " + j_ind);
            j_ind = edgeTo[j_ind][i_ind].v1;
            i_ind--;
        }
    }
    return vert_seam;
}