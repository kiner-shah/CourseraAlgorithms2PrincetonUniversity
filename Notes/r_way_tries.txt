// String symbol table: symbol table specialized to string keys
// Tries - from retrieval, but pronounced "try"
// For now, store characters in nodes (not keys)
// Each node has R children, one for each possible character (for now we do not draw null links)
// Store values in nodes corresponding to last character in keys

// Search in a trie: Follow links corresponding to each character in the key:
//	1. Search hit: node where search ends has a non-null value
//	2. Search miss: reach null link or node where search ends has null value

// Insertion in a trie: Follow links corresponding to each character in the key:
//	1. Encounter a null link: create new node
//	2. Encounter the last character of the key: set value in that node


public class TrieST<Value> {
	private static final int R = 256;	// extended ASCII
	private Node root = new Node();
	private static class Node {
		private Object value; // use Object instead of Value since no generic array creation in Java
		private Node[] next = new Node[R];
	}
	public void put(String key, Value val) {
		root = put(root, key, val, 0);
	}
	private Node put(Node x, String key, Value val, int d) {
		if (x == null) x = new Node();
		if (d == key.length()) { x.val = val; return x; }
		char c = key.charAt(d);
		x.next[c] = put(x.next[c], key, val, d + 1);
		return x;
	}
	public boolean contains(String key) {
		return get(key) != null;
	}
	public Value get(String key) {
		Node x = get(root, key, 0);
		if (x == null) return null;
		return (Value) x.val;	// cast needed
	}
	private Node get(Node x, String key, int d) {
		if (x == null) return null;
		if (d == key.length()) return x;
		char c = key.charAt(d);
		return get(x.next[c], key, d + 1);
	}
}

// Search hit: need to examine all L characters for equality
// Search miss: could have mismatch on first character (typical case: examine only a few characters (sublinear))
// Space: R null links at each leaf (but sublinear space possible if many short strings share common prefixes)

// Applications: spell checking - 26-way (english) trie (key = word, value = bit)

// Deletion in an R-way trie: to delete a key-value pair:
//	1. Find the node corresponding to key and set value to null
//	2. If that node has all null links, remove that node (and recur)
