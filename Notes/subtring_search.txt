// Find pattern of length M in a text of length N
// Screen scraping: extract relevant data from web page

// Brute force substring search: check for pattern starting at each text position
// Slow if text and pattern are repetitive
// Worst case ~MN compares
public static int search(String pat, String txt) {
	int M = pat.length();
	int N = txt.length();
	for (int i = 0; i <= N - M; i++) {
		int j;
		for (j = 0; j < M; j++)
			if (txt.charAt(i + j) != pat.charAt(j))
				break;
		if (j == M) return i;	// index in text where pattern starts
	}
	return N;
}

// Backup: In many applications, we want to avoid backup in text stream:
//	1. Treat input as stream of data
//	2. Abstract model: standard input
// Brute force algorithm needs backup for every mismatch
// Solution: maintain buffer of last M characters (another solution later explained)

// Alternate implementation
// Same sequence of char compares as previous implementation
//	1. i points to end of sequence of already-matched chars in text
//	2. j stores number of already-matched chars (end of sequence in pattern)
public static int search(String pat, String txt) {
	int i, M = txt.length();
	int j, N = pat.length();
	for (i = 0, j = 0; i < N && j < M; i++) {
		if (txt.charAt(i) == pat.charAt(j)) j++;
		else { i -= j; j = 0; }
	}
	if (j == M) retunr i - M;
	else return N;
}
// Theoretical challenge: linear-time guarantee (fundamental algorithmic problem)
// Practical challenge: avoid backup in text stream (offer no room or time to save text)