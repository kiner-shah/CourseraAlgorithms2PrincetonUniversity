// String: sequence of characters

// C char data type: 8-bit integer
// Supports 7-bit ASCII - can represent only 256 characters

// Java char data type: 16-bit unsigned integer
// Supports original 16-bit Unicode
// Supports 21-bit Unicode 3.0 (awkwardly)

// String data type in Java: sequence of characters (immutable)
// Length = no. of characters
// Indexing = get the i th character
// Substring extraction = get contiguous subsequence of characters
// String concatenation = append one character to end of another string
// Memory: 40 + 2N bytes for a virgin String of length N
public final class String implements Comparable<String> {
	private char[] value;	// characters
	private int offset;	// index of first char in array
	private int length;	// length of string
	private int hash;	// cache of hashCode()

	public int length() { return length; }
	public char charAt(int i) { return value[i + offset]; }
	private String(int offset, int length, char[] value) {
		this.offset = offset;
		this.length = length;
		this.value = value;
	}
	public String substring(int from, int to) {
		// value is copy of reference to original char array
		return new String(offset + from, to - from, value);
	}
	...
}
// StringBuilder data type: sequence of characters (mutable)
// Underlying implementation: resizing char[] array and length
// StringBuffer data type is similar but thread safe (and slower)

// Reverse a string using StringBuilder
// This is because concat operation using String takes linear time whereas in StringBuilder it takes constant time
public static String reverse(String s) {
	StringBuilder rev = new StringBuilder();
	for (int i = s.length - 1; i >= 0; i--)
		rev.append(s.charAt(i));
	return rev.toString();
}

// Forming an array of suffixes using String
// This is because StringBuilder takes quadratic time and space for substring operation whereas String takes linear time and space
public static String[] suffixes(String s) {
	int N = s.length();
	String[] suffixes = new String[N];
	for (int i = 0; i < N; i++)
		suffixes[i] = s.substring(i, N);
	return suffixes;
}

// Longest common prefix of two strings
// Running time proportional to length of LCP
public static int lcp(String s, String t) {
	int N = Math.min(s.length(), t.length());
	for (int i = 0; i < N; i++)
		if (s.charAt(i) != t.charAt(i))
			return i;
	return N;
}