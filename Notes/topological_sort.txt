// Precedence scheduling: Given a set of tasks to be completed with precedence constraints in which order should we schedule the tasks?
// Topological sort works on a Directed Acyclic Graph (DAG)
// Use DFS

// Algorithm:
//	1. Run DFS
//	2. Return vertices in reverse postorder

public class DepthFirstOrder {
	private boolean[] marked;
	private Stack<Integer> reversePost;

	public DepthFirstOrder(Digraph G) {
		reversePost = new Stack<Integer>();
		marked = new boolean[G.V()];
		for (int v = 0; v < G.V(); v++) {
			if (!marked[v]) dfs(G, v);
		}
	}
	private void dfs(Digraph G, int v) {
		marked[v] = true;
		for (int w : G.adj(v)) {
			if (!marked[w]) dfs(G, w);
		}
		reversePost.push(v);
	}
	public Iterable<Integer> reversePost() {
		return reversePost;
	}
}

// A digraph has a topological order iff no directed cycle

// Java compiler does cycle detection to detect cycle inheritance
// Microsoft Excel does cycle detection to detect spreadsheet recalculation